get_arima_preds <- function(df, h){
    # Only need test data
    station_str <- paste("horizon-", h, "_cov", sep="")
    df %>% select(ends_with("observed"), c(ends_with(station_str))) -> station_data
    # Why do I need to chop off the first rows up to the horizon?
    # Because I trained the model starting at the test set, instead of indexing it backwards
    # to start forecasting at all the same point. Either way could have been okay.
    station_data <- station_data[h:nrow(df), ]
    return(station_data)
}

prepare_transformer <- function(preds){
    # Break up the ids to get just the station name
    split_ts <- str_split(preds$station, "_")
    # Get just the station name and the obs/pred label
    station_ids <- sapply(split_ts, "[", c(1,3))  # Returns matrix
    preds$station_id <- paste(station_ids[1,], station_ids[2,], sep="_")
    # An ok way to do this is to make long first and then go wide
    # This allows the columns to actually correspond to the time series indices (up to 116 
    # but only 94 of those have values in the h=1 case)
    # Drop station
    preds <- preds[!names(preds) %in% c("station")]
    cols_for_long <- colnames(preds)[colnames(preds)!=c("station_id")]
    preds_transpose_long <- pivot_longer(preds, cols=all_of(cols_for_long)) 
    preds_transpose_long %>% group_by(station_id) %>% mutate(index = row_number()) -> preds_transpose_long
    preds_transpose_long %>% pivot_wider(values_from = value, id_cols=station_id, names_from=index) -> preds_transpose_wide
    # Messier way
    #transformer_preds %>% group_by(station_id) %>% mutate(index = row_number()) -> transformer_preds
    #preds_transpose <- pivot_wider(transformer_preds, values_from = X1:X29, id_cols = station_id, names_from = index)
    
    preds_transpose_wide %>% filter(str_detect(station_id, "pred")) %>% arrange(station_id) -> tf_preds 
    preds_transpose_wide %>% filter(str_detect(station_id, "obs")) %>% arrange(station_id) -> tf_obs 
    return(list(tf_full=preds_transpose_wide, tf_preds=tf_preds, tf_obs=tf_obs))
}

# Function to drop the elements from the arima forecasts that were not 
# generated by the transformer, due to the splitting of the data into smaller time series.
drop_arima_elements <- function(mat, h){
    if (h==1){
        clean_mat <- mat[, c(1:29, 31:59, 61:89, 91:ncol(mat))]
    }else if (h==5){
        clean_mat <- mat[, c(1:25, 31:55, 61:85, 91:ncol(mat))]
    }else{
        clean_mat <- mat[, c(1:20, 31:50, 61:80)]
    }
    return(clean_mat)
}

# The following handling is done because of the way I did batches and split up the series. 
# It is not trivial to handle this in an more elegant way, so I am hardcoding the batch size and
# splits into this block, unfortunately.
# This will be 94 instead of 98 - 1 because I split the time series into 4, so we have to take - 4.
# Also, remember that there will be 94 values because the last batch will have a bunch of empty elements
# at the end.
check_tf_matrices <- function(h, tf_preds, tf_obs){
    if (h == 0){
        stopifnot(ncol(tf_preds)==121)
        tf_preds_matrix <- as.matrix(tf_preds[, names(tf_preds) != "station_id"])[, 1:98]
        tf_obs_matrix <- as.matrix(tf_obs[, names(tf_obs) != "station_id"])[, 1:98]
    } else if (h == 1){
        stopifnot(ncol(tf_preds)==117)
        tf_preds_matrix <- as.matrix(tf_preds[, names(tf_preds) != "station_id"])[, 1:94]
        tf_obs_matrix <- as.matrix(tf_obs[, names(tf_obs) != "station_id"])[, 1:94]
    } else if (h == 5){
        stopifnot(ncol(tf_preds)==101)
        tf_preds_matrix <- as.matrix(tf_preds[, names(tf_preds) != "station_id"])[, 1:78]
        tf_obs_matrix <- as.matrix(tf_obs[, names(tf_obs) != "station_id"])[, 1:78]
    } else{
        stopifnot(ncol(tf_preds)==81)
        tf_preds_matrix <- as.matrix(tf_preds[, names(tf_preds) != "station_id"])[, 1:60]
        tf_obs_matrix <- as.matrix(tf_obs[, names(tf_obs) != "station_id"])[, 1:60]
    }
    return(list(tf_preds_matrix=tf_preds_matrix, tf_obs_matrix=tf_obs_matrix))
}