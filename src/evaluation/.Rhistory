dim(tf_ts)
# Split into one df for obs and another for preds
tf_ts %>% filter(str_detect(station_id, "pred")) %>% arrange(station_id) -> tf_preds
tf_ts %>% filter(str_detect(station_id, "obs")) %>% arrange(station_id) -> tf_obs
fileout <- paste("../../data/model_output/mvts/transpose_forecast_out_bxl_eval_h-", h, "_", chem, ".csv", sep="")
write.csv(tf_ts, fileout)
# Next handle VAR
arima_df <- get_arima_preds(arima_chem_df, h)
stopifnot(ncol(arima_df) == 82)
arima_transpose <- t(arima_df)
arima_t_df <- as.data.frame(arima_transpose)
arima_t_df$station_id <- rownames(arima_transpose)
rownames(arima_t_df) <- NULL
# Station id will be the last column so set seq id up to that.
names(arima_t_df)[1:nrow(arima_df)] <- 1:nrow(arima_df)
# Move station id to front
arima_t_df <- arima_t_df %>%
select(station_id, everything())
arima_t_df %>% filter(str_detect(station_id, "horizon")) %>% arrange(station_id) -> arima_preds
arima_t_df %>% filter(str_detect(station_id, "observed")) %>% arrange(station_id) -> arima_obs
stopifnot(dim(arima_preds) == dim(tf_preds))
dim(tf_preds)
View(tf_obs)
View(arima_obs)
h
h_index=1
h <- H[h_index]
# First handle transformer
filepath <- paste("../../data/model_output/mvts/forecast_out_bxl_eval_h-", h, "_", chem, ".csv", sep="")
transformer_preds <- read.csv(filepath, header=T)
# Combine rows from the same station.
tf_ts <- prepare_transformer(transformer_preds)
dim(tf_ts)
# Split into one df for obs and another for preds
tf_ts %>% filter(str_detect(station_id, "pred")) %>% arrange(station_id) -> tf_preds
tf_ts %>% filter(str_detect(station_id, "obs")) %>% arrange(station_id) -> tf_obs
fileout <- paste("../../data/model_output/mvts/transpose_forecast_out_bxl_eval_h-", h, "_", chem, ".csv", sep="")
write.csv(tf_ts, fileout)
# Next handle VAR
arima_df <- get_arima_preds(arima_chem_df, h)
stopifnot(ncol(arima_df) == 82)
arima_transpose <- t(arima_df)
arima_t_df <- as.data.frame(arima_transpose)
arima_t_df$station_id <- rownames(arima_transpose)
rownames(arima_t_df) <- NULL
# Station id will be the last column so set seq id up to that.
names(arima_t_df)[1:nrow(arima_df)] <- 1:nrow(arima_df)
# Move station id to front
arima_t_df <- arima_t_df %>%
select(station_id, everything())
arima_t_df %>% filter(str_detect(station_id, "horizon")) %>% arrange(station_id) -> arima_preds
arima_t_df %>% filter(str_detect(station_id, "observed")) %>% arrange(station_id) -> arima_obs
stopifnot(dim(arima_preds) == dim(tf_preds))
h_index=5
h <- H[h_index]
# First handle transformer
filepath <- paste("../../data/model_output/mvts/forecast_out_bxl_eval_h-", h, "_", chem, ".csv", sep="")
transformer_preds <- read.csv(filepath, header=T)
h_index=2
# First handle transformer
filepath <- paste("../../data/model_output/mvts/forecast_out_bxl_eval_h-", h, "_", chem, ".csv", sep="")
h <- H[h_index]
# First handle transformer
filepath <- paste("../../data/model_output/mvts/forecast_out_bxl_eval_h-", h, "_", chem, ".csv", sep="")
transformer_preds <- read.csv(filepath, header=T)
# Combine rows from the same station.
tf_ts <- prepare_transformer(transformer_preds)
dim(tf_ts)
# Split into one df for obs and another for preds
tf_ts %>% filter(str_detect(station_id, "pred")) %>% arrange(station_id) -> tf_preds
tf_ts %>% filter(str_detect(station_id, "obs")) %>% arrange(station_id) -> tf_obs
fileout <- paste("../../data/model_output/mvts/transpose_forecast_out_bxl_eval_h-", h, "_", chem, ".csv", sep="")
write.csv(tf_ts, fileout)
# Next handle VAR
arima_df <- get_arima_preds(arima_chem_df, h)
stopifnot(ncol(arima_df) == 82)
arima_transpose <- t(arima_df)
arima_t_df <- as.data.frame(arima_transpose)
arima_t_df$station_id <- rownames(arima_transpose)
rownames(arima_t_df) <- NULL
# Station id will be the last column so set seq id up to that.
names(arima_t_df)[1:nrow(arima_df)] <- 1:nrow(arima_df)
# Move station id to front
arima_t_df <- arima_t_df %>%
select(station_id, everything())
# Now, I need to remove the observations from arima that will not correspond to those from tf
# This is an artifact of splitting the tf predictions into subsets of 30 seq.
arima_clean_df <- drop_arima_elements(arima_t_df, h)
arima_t_df %>% filter(str_detect(station_id, "horizon")) %>% arrange(station_id) -> arima_preds
arima_t_df %>% filter(str_detect(station_id, "observed")) %>% arrange(station_id) -> arima_obs
View(arima_preds)
View(arima_t_df)
View(arima_df
View(arima_df)
View(arima_df)
get_arima_preds <- function(df, h){
# Only need test data
station_str <- paste("horizon-", h, "_cov", sep="")
df %>% select(ends_with("observed"), c(ends_with(station_str))) -> station_data
df <- df[h:nrows(df), ]
return(station_data)
}
# Next handle VAR
arima_df <- get_arima_preds(arima_chem_df, h)
get_arima_preds <- function(df, h){
# Only need test data
station_str <- paste("horizon-", h, "_cov", sep="")
df %>% select(ends_with("observed"), c(ends_with(station_str))) -> station_data
df <- df[h:nrow(df), ]
return(station_data)
}
# Next handle VAR
arima_df <- get_arima_preds(arima_chem_df, h)
stopifnot(ncol(arima_df) == 82)
arima_transpose <- t(arima_df)
arima_t_df <- as.data.frame(arima_transpose)
arima_t_df$station_id <- rownames(arima_transpose)
rownames(arima_t_df) <- NULL
# Station id will be the last column so set seq id up to that.
names(arima_t_df)[1:nrow(arima_df)] <- 1:nrow(arima_df)
# Move station id to front
arima_t_df <- arima_t_df %>%
select(station_id, everything())
arima_t_df %>% filter(str_detect(station_id, "horizon")) %>% arrange(station_id) -> arima_preds
arima_t_df %>% filter(str_detect(station_id, "observed")) %>% arrange(station_id) -> arima_obs
stopifnot(dim(arima_preds) == dim(tf_preds))
dim(arima_preds)
dim(tf_preds)
View(arima_obs)
View(arima_preds)
get_arima_preds <- function(df, h){
# Only need test data
station_str <- paste("horizon-", h, "_cov", sep="")
df %>% select(ends_with("observed"), c(ends_with(station_str))) -> station_data
df <- df[h:nrow(df), ]
return(station_data)
}
chem_names <- c("pm25", "pm10", "no2")
chem_ids <- vector(mode="list", length=length(chem_names))
names(chem_ids) <- chem_names
chem_ids[[1]] <- 6001
chem_ids[[2]] <- 5
chem_ids[[3]] <- 8
get_arima_preds <- function(df, h){
# Only need test data
station_str <- paste("horizon-", h, "_cov", sep="")
df %>% select(ends_with("observed"), c(ends_with(station_str))) -> station_data
df <- df[h:nrow(df), ]
return(station_data)
}
prepare_transformer <- function(preds){
# Break up the ids to get just the station name
split_ts <- str_split(preds$station, "_")
# Get just the station name and the obs/pred label
station_ids <- sapply(split_ts, "[", c(1,3))  # Returns matrix
preds$station_id <- paste(station_ids[1,], station_ids[2,], sep="_")
# An ok way to do this is to make long first and then go wide
# This allows the columns to actually correspond to the time series indices (up to 116
# but only 94 of those have values in the h=1 case)
preds_transpose_long <- pivot_longer(preds, cols=colnames(transformer_preds)[colnames(transformer_preds)!=c("station")])
preds_transpose_long %>% group_by(station_id) %>% mutate(index = row_number()) -> preds_transpose_long
preds_transpose_long %>% pivot_wider(values_from = value, id_cols=station_id, names_from=index) -> preds_transpose_wide
# Messier way
#transformer_preds %>% group_by(station_id) %>% mutate(index = row_number()) -> transformer_preds
#preds_transpose <- pivot_wider(transformer_preds, values_from = X1:X29, id_cols = station_id, names_from = index)
return(preds_transpose_wide)
}
H <- c(1, 5, 10)
chem
# Next handle VAR
arima_df <- get_arima_preds(arima_chem_df, h)
stopifnot(ncol(arima_df) == 82)
arima_transpose <- t(arima_df)
arima_t_df <- as.data.frame(arima_transpose)
arima_t_df$station_id <- rownames(arima_transpose)
rownames(arima_t_df) <- NULL
# Station id will be the last column so set seq id up to that.
names(arima_t_df)[1:nrow(arima_df)] <- 1:nrow(arima_df)
# Move station id to front
arima_t_df <- arima_t_df %>%
select(station_id, everything())
# Now, I need to remove the observations from arima that will not correspond to those from tf
# This is an artifact of splitting the tf predictions into subsets of 30 seq.
arima_clean_df <- drop_arima_elements(arima_t_df, h)
arima_t_df %>% filter(str_detect(station_id, "horizon")) %>% arrange(station_id) -> arima_preds
arima_t_df %>% filter(str_detect(station_id, "observed")) %>% arrange(station_id) -> arima_obs
stopifnot(dim(arima_preds) == dim(tf_preds))
View(arima_obs)
View(arima_preds)
h
View(arima_df)
arima_df[h:norw(arima_df)]
arima_df[h:nrow(arima_df),]
test_df <- arima_df[h:nrow(arima_df),]
View(test_df)
get_arima_preds <- function(df, h){
# Only need test data
station_str <- paste("horizon-", h, "_cov", sep="")
df %>% select(ends_with("observed"), c(ends_with(station_str))) -> station_data
station_data <- station_data[h:nrow(df), ]
return(station_data)
}
# Next handle VAR
arima_df <- get_arima_preds(arima_chem_df, h)
stopifnot(ncol(arima_df) == 82)
arima_transpose <- t(arima_df)
arima_t_df <- as.data.frame(arima_transpose)
arima_t_df$station_id <- rownames(arima_transpose)
rownames(arima_t_df) <- NULL
# Station id will be the last column so set seq id up to that.
names(arima_t_df)[1:nrow(arima_df)] <- 1:nrow(arima_df)
# Move station id to front
arima_t_df <- arima_t_df %>%
select(station_id, everything())
# Now, I need to remove the observations from arima that will not correspond to those from tf
# This is an artifact of splitting the tf predictions into subsets of 30 seq.
arima_clean_df <- drop_arima_elements(arima_t_df, h)
arima_t_df %>% filter(str_detect(station_id, "horizon")) %>% arrange(station_id) -> arima_preds
arima_t_df %>% filter(str_detect(station_id, "observed")) %>% arrange(station_id) -> arima_obs
stopifnot(ncol(tf_preds)==101)
dim(arima_t_df)
View(arima_t_df)
# Function to drop the elements from the arima forecasts that were not
# generated by the transformer, due to the splitting of the data into smaller time series.
drop_arima_elements <- function(mat, h){
if (h==5){
clean_mat <- mat[c(1:25, 31:55, 61:85, 91:ncol(mat))]
}
return(clean_mat)
}
arima_preds_matrix <- as.matrix(arima_preds[, names(arima_preds) != "station_id"])
arima_obs_matrix <- as.matrix(arima_obs[, names(arima_obs) != "station_id"])
arima_preds_matrix
dim(arima_preds_matrix)
View(arima_preds_matrix)
# Now drop the values that won't correspond to those in the tf forecast. It's easier to do this
# as a matrix.
arima_preds_mx_clean <- drop_arima_elements(arima_preds_matrix, h)
arima_obs_mx_clean <- drop_arima_elements(arima_obs_matrix, h)
dim(arima_preds_matrix)
dim(arima_preds_mx_clean)
# Function to drop the elements from the arima forecasts that were not
# generated by the transformer, due to the splitting of the data into smaller time series.
drop_arima_elements <- function(mat, h){
if (h==5){
clean_mat <- mat[c(1:25, 31:55, 61:85, 91:ncol(mat))]
}
return(clean_mat)
}
# Now drop the values that won't correspond to those in the tf forecast. It's easier to do this
# as a matrix.
arima_preds_mx_clean <- drop_arima_elements(arima_preds_matrix, h)
arima_obs_mx_clean <- drop_arima_elements(arima_obs_matrix, h)
dim(arima_preds_mx_clean)
View(arima_preds_mx_clean)
arima_preds_matrix[c(1:2, 3:4),]
# Function to drop the elements from the arima forecasts that were not
# generated by the transformer, due to the splitting of the data into smaller time series.
drop_arima_elements <- function(mat, h){
if (h==5){
clean_mat <- mat[, c(1:25, 31:55, 61:85, 91:ncol(mat))]
}
return(clean_mat)
}
# Now drop the values that won't correspond to those in the tf forecast. It's easier to do this
# as a matrix.
arima_preds_mx_clean <- drop_arima_elements(arima_preds_matrix, h)
arima_obs_mx_clean <- drop_arima_elements(arima_obs_matrix, h)
dim(arima_preds_mx_clean)
View(tf_preds)
29*4
29*3
29*3 + 7
fileout_var <- paste("../../data/model_output/arima/transpose_forecast_out_h-", h, "_", chem, ".csv", sep="")
write.csv(arima_t_df, fileout_var)
# TODO: Which values do I need to get from var forecasts, ie 1:94
# Then save var and tf matrix so we can compute error element wise.
# Dropping station id first, to be added later
# The following handling is done because of the way I did batches and split up the series.
# It is not trivial to handle this in an more elegant way, so I am hardcoding the batch size and
# splits into this block, unfortunately.
# This will be 94 instead of 98 - 1 because I split the time series into 4, so we have to take - 4.
if (h == 1){
# 29 * 3 + 7 = 94 because 29 steps in each series
# The same logic follows for the rest of the tests
stopifnot(ncol(tf_preds)==117)
tf_preds_matrix <- as.matrix(tf_preds[, names(tf_preds) != "station_id"])[, 1:94]
tf_obs_matrix <- as.matrix(tf_obs[, names(tf_obs) != "station_id"])[, 1:94]
} else if (h == 5){
stopifnot(ncol(tf_preds)==101)
tf_preds_matrix <- as.matrix(tf_preds[, names(tf_preds) != "station_id"])[, 1:78]
tf_obs_matrix <- as.matrix(tf_obs[, names(tf_obs) != "station_id"])[, 1:78]
} else{
stopifnot(ncol(tf_preds)==81)
tf_preds_matrix <- as.matrix(tf_preds[, names(tf_preds) != "station_id"])[, 1:60]
tf_obs_matrix <- as.matrix(tf_obs[, names(tf_obs) != "station_id"])[, 1:60]
}
stopifnot(dim(arima_preds) == dim(tf_preds_matrix))
stopifnot(dim(arima_obs) == dim(tf_obs_matrix))
stopifnot(dim(arima_preds_mx_clean) == dim(tf_preds_matrix))
stopifnot(dim(arima_obs_mx_clean) == dim(tf_obs_matrix))
# Compute errors
tf_error <- tf_obs_matrix - tf_preds_matrix
dim(tf_obs_matrix
)
stopifnot(tf_obs_matrix == arima_obs_mx_clean)
View(tf_obs_matrix)
View(arima_obs_mx_clean)
stopifnot(round(tf_obs_matrix, 2) == round(arima_obs_mx_clean))
stopifnot(round(tf_obs_matrix, 2) == round(arima_obs_mx_clean, 2))
round(tf_obs_matrix,2)
stopifnot(round(tf_obs_matrix, 1) == round(arima_obs_mx_clean, 1))
round(tf_obs_matrix,1)
var_error <- arima_obs_mx_clean - arima_preds_mx_clean
oos_errors <- matrix(nrow=41, ncol=12)
tf_oos_errors <- matrix(nrow=41, ncol=12)
# TODO: Not sure if I want one matrix or two to compare these.
if (h_index == 1){
tf_oos_errors[, 1] <- tf_rmse_vec
tf_oos_errors[, 2] <- tf_mae_vec
tf_oos_errors[, 3] <- var_rmse_vec
tf_oos_errors[, 4] <- var_mae_vec
} else if (h_index == 2){
tf_oos_errors[, 5] <- tf_rmse_vec
tf_oos_errors[, 6] <- tf_mae_vec
tf_oos_errors[, 7] <- var_rmse_vec
tf_oos_errors[, 8] <- var_mae_vec
} else {
tf_oos_errors[, 9] <- tf_rmse_vec
tf_oos_errors[, 10] <- tf_mae_vec
tf_oos_errors[, 11] <- var_rmse_vec
tf_oos_errors[, 12] <- var_mae_vec
}
# Then compute metrics
tf_mae_vec <- rowMeans(abs(tf_error))
tf_rmse_vec <- sqrt(rowMeans(tf_error^2))
var_mae_vec <- rowMeans(abs(var_error))
var_rmse_vec <- sqrt(rowMeans(var_error^2))
# TODO: Not sure if I want one matrix or two to compare these.
if (h_index == 1){
tf_oos_errors[, 1] <- tf_rmse_vec
tf_oos_errors[, 2] <- tf_mae_vec
tf_oos_errors[, 3] <- var_rmse_vec
tf_oos_errors[, 4] <- var_mae_vec
} else if (h_index == 2){
tf_oos_errors[, 5] <- tf_rmse_vec
tf_oos_errors[, 6] <- tf_mae_vec
tf_oos_errors[, 7] <- var_rmse_vec
tf_oos_errors[, 8] <- var_mae_vec
} else {
tf_oos_errors[, 9] <- tf_rmse_vec
tf_oos_errors[, 10] <- tf_mae_vec
tf_oos_errors[, 11] <- var_rmse_vec
tf_oos_errors[, 12] <- var_mae_vec
}
tf_oos_df <- as.data.frame(tf_oos_errors)
# Station id will be indexed correctly to account for station order
split_names <- str_split(tf_preds$station_id, "_")
# Get just the station name and the obs/pred label
station_names <- sapply(split_names, "[", 1)  # Returns matrix
# Get just the station name and the obs/pred label
station_names <- sapply(split_names, "[", 1)  # Returns matrix
tf_oos_df$station <- station_names
new_names <- c("TF H-1 RMSE", "TF H-1 MAE", "VAR H-1 RMSE", "VAR H-1 MAE",
"TF H-5 RMSE", "TF H-5 MAE", "VAR H-5 RMSE", "VAR H-5 MAE",
"TF H-10 RMSE", "TF H-10 MAE", "VAR H-10 RMSE", "VAR H-10 MAE",
paste("Station measuring", chem))
#new_names <- c("H-1 RMSE", "H-1 MAE", "H-5 RMSE", "H-5 MAE", "H-10 RMSE", "H-10 MAE", paste("Station measuring", chem))
colnames(tf_oos_df) <- new_names
print("Transformer forecasts")
print(kbl(tf_oos_df, booktabs = T, format="latex"))
# Function to drop the elements from the arima forecasts that were not
# generated by the transformer, due to the splitting of the data into smaller time series.
drop_arima_elements <- function(mat, h){
if (h==1){
clean_mat <- mat[, c(1:29, 31:59, 61:89, 91:ncol(mat))]
}
if (h==5){
clean_mat <- mat[, c(1:25, 31:55, 61:85, 91:ncol(mat))]
}else{
clean_mat <- mat[, c(1:20, 31:50, 61:80)]
}
return(clean_mat)
}
H <- c(1, 5, 10)
for (chem_index in 1:length(chem_ids)){
chem_id <- chem_ids[[chem_index]]
chem <- names(chem_ids)[chem_index]
# Arima preds are saved per chem
arima_chem_df <- read.csv(paste("../../data/model_output/arima/", toupper(chem), "_VAR_forecasts.csv", sep=""), header=T, check.names = F)
# Only need test data
# Hardcoded based on test split!
arima_chem_df <- arima_chem_df[362:nrow(arima_chem_df),]
# Have 1 table to compare each chemical, all horizons
dm_tests <- matrix(nrow=41, ncol=3)
tf_oos_errors <- matrix(nrow=41, ncol=12)
#ar_oos_errors <- matrix(nrow=41, ncol=6)
for (h_index in 1:length(H)){
h <- H[h_index]
# First handle transformer
filepath <- paste("../../data/model_output/mvts/forecast_out_bxl_eval_h-", h, "_", chem, ".csv", sep="")
transformer_preds <- read.csv(filepath, header=T)
# Combine rows from the same station.
tf_ts <- prepare_transformer(transformer_preds)
dim(tf_ts)
# Split into one df for obs and another for preds
tf_ts %>% filter(str_detect(station_id, "pred")) %>% arrange(station_id) -> tf_preds
tf_ts %>% filter(str_detect(station_id, "obs")) %>% arrange(station_id) -> tf_obs
fileout <- paste("../../data/model_output/mvts/transpose_forecast_out_bxl_eval_h-", h, "_", chem, ".csv", sep="")
write.csv(tf_ts, fileout)
# Next handle VAR
arima_df <- get_arima_preds(arima_chem_df, h)
stopifnot(ncol(arima_df) == 82)
arima_transpose <- t(arima_df)
arima_t_df <- as.data.frame(arima_transpose)
arima_t_df$station_id <- rownames(arima_transpose)
rownames(arima_t_df) <- NULL
# Station id will be the last column so set seq id up to that.
names(arima_t_df)[1:nrow(arima_df)] <- 1:nrow(arima_df)
# Move station id to front
arima_t_df <- arima_t_df %>%
select(station_id, everything())
# Now, I need to remove the observations from arima that will not correspond to those from tf
# This is an artifact of splitting the tf predictions into subsets of 30 seq.
arima_t_df %>% filter(str_detect(station_id, "horizon")) %>% arrange(station_id) -> arima_preds
arima_t_df %>% filter(str_detect(station_id, "observed")) %>% arrange(station_id) -> arima_obs
arima_preds_matrix <- as.matrix(arima_preds[, names(arima_preds) != "station_id"])
arima_obs_matrix <- as.matrix(arima_obs[, names(arima_obs) != "station_id"])
# Now drop the values that won't correspond to those in the tf forecast. It's easier to do this
# as a matrix.
arima_preds_mx_clean <- drop_arima_elements(arima_preds_matrix, h)
arima_obs_mx_clean <- drop_arima_elements(arima_obs_matrix, h)
# Write transpose out
fileout_var <- paste("../../data/model_output/arima/transpose_forecast_out_h-", h, "_", chem, ".csv", sep="")
write.csv(arima_t_df, fileout_var)
# TODO: Which values do I need to get from var forecasts, ie 1:94
# Then save var and tf matrix so we can compute error element wise.
# Dropping station id first, to be added later
# The following handling is done because of the way I did batches and split up the series.
# It is not trivial to handle this in an more elegant way, so I am hardcoding the batch size and
# splits into this block, unfortunately.
# This will be 94 instead of 98 - 1 because I split the time series into 4, so we have to take - 4.
if (h == 1){
# 29 * 3 + 7 = 94 because 29 steps in each series
# The same logic follows for the rest of the tests
stopifnot(ncol(tf_preds)==117)
tf_preds_matrix <- as.matrix(tf_preds[, names(tf_preds) != "station_id"])[, 1:94]
tf_obs_matrix <- as.matrix(tf_obs[, names(tf_obs) != "station_id"])[, 1:94]
} else if (h == 5){
stopifnot(ncol(tf_preds)==101)
tf_preds_matrix <- as.matrix(tf_preds[, names(tf_preds) != "station_id"])[, 1:78]
tf_obs_matrix <- as.matrix(tf_obs[, names(tf_obs) != "station_id"])[, 1:78]
} else{
stopifnot(ncol(tf_preds)==81)
tf_preds_matrix <- as.matrix(tf_preds[, names(tf_preds) != "station_id"])[, 1:60]
tf_obs_matrix <- as.matrix(tf_obs[, names(tf_obs) != "station_id"])[, 1:60]
}
# Dimensions should be (41, 94) for h=1, (41, 78) for h=5, and (41, 60) for h=10
stopifnot(dim(arima_preds_mx_clean) == dim(tf_preds_matrix))
stopifnot(dim(arima_obs_mx_clean) == dim(tf_obs_matrix))
stopifnot(round(tf_obs_matrix, 1) == round(arima_obs_mx_clean, 1))
# Compute errors
tf_error <- tf_obs_matrix - tf_preds_matrix
var_error <- arima_obs_mx_clean - arima_preds_mx_clean
# Then compute metrics
tf_mae_vec <- rowMeans(abs(tf_error))
tf_rmse_vec <- sqrt(rowMeans(tf_error^2))
var_mae_vec <- rowMeans(abs(var_error))
var_rmse_vec <- sqrt(rowMeans(var_error^2))
# TODO: Not sure if I want one matrix or two to compare these.
if (h_index == 1){
tf_oos_errors[, 1] <- tf_rmse_vec
tf_oos_errors[, 2] <- tf_mae_vec
tf_oos_errors[, 3] <- var_rmse_vec
tf_oos_errors[, 4] <- var_mae_vec
} else if (h_index == 2){
tf_oos_errors[, 5] <- tf_rmse_vec
tf_oos_errors[, 6] <- tf_mae_vec
tf_oos_errors[, 7] <- var_rmse_vec
tf_oos_errors[, 8] <- var_mae_vec
} else {
tf_oos_errors[, 9] <- tf_rmse_vec
tf_oos_errors[, 10] <- tf_mae_vec
tf_oos_errors[, 11] <- var_rmse_vec
tf_oos_errors[, 12] <- var_mae_vec
}
#dm_tests[i, 1] <- h
#dm_tests[i, 2] <- dm.test(error_cov, error_nocov,h=h,power=1)$p.value[[1]]
#dm_tests[i, 3] <- dm.test(error_cov, error_nocov,h=h,power=2)$p.value[[1]]
}
tf_oos_df <- as.data.frame(tf_oos_errors)
# Station id will be indexed correctly to account for station order
split_names <- str_split(tf_preds$station_id, "_")
# Get just the station name and the obs/pred label
station_names <- sapply(split_names, "[", 1)  # Returns matrix
tf_oos_df$station <- station_names
new_names <- c("TF H-1 RMSE", "TF H-1 MAE", "VAR H-1 RMSE", "VAR H-1 MAE",
"TF H-5 RMSE", "TF H-5 MAE", "VAR H-5 RMSE", "VAR H-5 MAE",
"TF H-10 RMSE", "TF H-10 MAE", "VAR H-10 RMSE", "VAR H-10 MAE",
paste("Station measuring", chem))
#new_names <- c("H-1 RMSE", "H-1 MAE", "H-5 RMSE", "H-5 MAE", "H-10 RMSE", "H-10 MAE", paste("Station measuring", chem))
colnames(tf_oos_df) <- new_names
print("Transformer forecasts")
print(kbl(tf_oos_df, booktabs = T, format="latex"))
}
dim(arima_preds_mx_clean)
h
dim(tf_preds_matrix)
view(arima_preds_matrix)
View(tf_obs_matrix)
View(tf_obs)
View(arima_obs_matrix)
