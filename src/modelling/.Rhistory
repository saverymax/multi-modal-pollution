gov_trust =~ trstprl +  trstep + trstun
# Trust in people
people_trust =~ ppltrst + pplfair + pplhlp
# Poltical ability
poltical_able =~ psppipla + psppsgva + cptppola
# Add residual covariance
trstep ~~ trstun
trstprl ~~ trstep
'
fit_politics_adj_2 <- cfa(politics_model_adj_2,
data = df_subset)
summary(fit_politics_adj_2, fit.measures=T, standardized=T)
m1=fitMeasures(fit_politics_adj_1, c("logl","AIC", "BIC", "chisq", "df", "pvalue", "cfi", "tli","rmsea"), output = "matrix")
m2=fitMeasures(fit_politics_adj_2, c("logl","AIC", "BIC", "chisq", "df", "pvalue", "cfi", "tli","rmsea"), output = "matrix")
df_compare <- data.frame(Fit=rownames(m1), "model with actrolga"=round(m1[,1],3), "model w/o actrolga"=round(m1[,1],3))
df_compare
# Let's remove actrolga
politics_model_adj_2 <- '
# Specify latent factors
# Trust in government
gov_trust =~ trstprl + trstprt + trstep + trstun
# Trust in people
people_trust =~ ppltrst + pplfair + pplhlp
# Poltical ability
# Add residual covariance
trstep ~~ trstun
trstprl ~~ trstep
'
fit_politics_adj_2 <- cfa(politics_model_adj_2,
data = df_subset)
summary(fit_politics_adj_2, fit.measures=T, standardized=T)
m1=fitMeasures(fit_politics_adj_1, c("logl","AIC", "BIC", "chisq", "df", "pvalue", "cfi", "tli","rmsea"), output = "matrix")
m2=fitMeasures(fit_politics_adj_2, c("logl","AIC", "BIC", "chisq", "df", "pvalue", "cfi", "tli","rmsea"), output = "matrix")
df_compare <- data.frame(Fit=rownames(m1), "model with actrolga"=round(m1[,1],3), "model w/o actrolga"=round(m1[,1],3))
df_compare
df_compare <- data.frame(Fit=rownames(m1), "model with actrolga"=round(m1[,1],3), "model w/o actrolga"=round(m2[,1],3))
df_compare
summary(fit_politics_adj_2, fit.measures=T, standardized=T)
m1=fitMeasures(fit_politics_adj_1, c("logl","AIC", "BIC", "chisq", "df", "pvalue", "cfi", "tli","rmsea", "srmr"), output = "matrix")
m2=fitMeasures(fit_politics_adj_2, c("logl","AIC", "BIC", "chisq", "df", "pvalue", "cfi", "tli","rmsea", "srmr"), output = "matrix")
df_compare <- data.frame(Fit=rownames(m1), "model with actrolga"=round(m1[,1],3), "model w/o actrolga"=round(m2[,1],3))
df_compare
# Let's remove actrolga
politics_model_adj_2 <- '
# Specify latent factors
# Trust in government
gov_trust =~ trstprl + trstprt + trstep + trstun
# Trust in people
people_trust =~ ppltrst + pplfair + pplhlp
# Poltical ability
poltical_able =~ psppipla + psppsgva + cptppola
# Add residual covariance
trstep ~~ trstun
trstprl ~~ trstep
'
fit_politics_adj_2 <- cfa(politics_model_adj_2,
data = df_subset)
summary(fit_politics_adj_2, fit.measures=T, standardized=T)
graph_data <- prepare_graph(fit_adj_2)
graph_data <- prepare_graph(fit_politics_adj_2)
edges(graph_data) <- graph_data %>%
edges() %>%
mutate(colour = "black")
plot(graph_data,
#label = "est_std",   # get standardized results (not rounded)
angle = 170          # adjust the arrows
)
plot(graph_data,
#label = "est_std",   # get standardized results (not rounded)
angle = 170          # adjust the arrows
)
### DATA MANIPULATION ###
library("haven")
library("dplyr")
library("psych")
library('stringr')
### MODELING ###
library("lavaan")
### VISUALIZATION ###
library("corrplot")
library("tidySEM")
# Why are there just some giant numbers in this data?
data_file <- "C:\\Users\\USER\\Documents\\ku_leuven\\courses\\structural_equations\\project\\ESS1-9e01_1\\ESS1-9e01_1_all_dates.csv"
df <- read.csv(data_file)
df$essround
df_round_select <- df[df$essround==9,]
dim(df_round_select)
# Works with round 5
# select_vars <- c("trstprl", "trstlgl", "trstplc", "trstplt", "trstprt", "trstep", "trstun", "tvtot", "tvpol", "rdtot", "rdpol", "nwsptot", "nwsppol", "netuse")
# Works with round 9
select_vars <- c("gndr", "trstprl", "trstlgl", "trstplc", "trstplt", "trstprt", "trstep", "trstun",
"psppipla", "actrolga", "psppsgva", "cptppola",
"psppsgva", "actrolga", "ppltrst", "pplfair", "pplhlp", "polintr")
# filter out 77. 88, 99 for refusal, don't know, or no answer.
# Weird notation in dplyr across
df %>% filter(essround==9) %>% select(select_vars) %>% filter(across(.cols=everything(), .fns=~ . <= 10)) -> df_subset
df_subset[is.na(df_subset)]
dim(df_subset)
cov_mat <- cov(df_subset, use = "pairwise.complete.obs")
corr_mat <- cov2cor(cov_mat)
corrplot::corrplot(corr_mat,
is.corr = T,       # whether is a correlation matrix
method = "circle",     # magnitude of covariances as circles
type = "upper",        # remove the bottom of the covariance matrix
addCoef.col = "black"  # add to the plot the coefficients
)
# Should I use polintr?
politics_model <- '
# Specify latent factors
# Trust in government
gov_trust =~ trstprl + trstprt + trstplt  + trstep + trstun
# Trust in people
people_trust =~ ppltrst + pplfair + pplhlp
# Poltical ability
poltical_able =~ psppipla + actrolga + psppsgva + cptppola
'
# Let's remove actrolga
politics_model_adj_2 <- '
# Specify latent factors
# Trust in government
gov_trust =~ trstprl + trstprt + trstep + trstun
# Trust in people
people_trust =~ ppltrst + pplfair + pplhlp
# Poltical ability
poltical_able =~ psppipla + psppsgva + cptppola
# Add residual covariance
trstep ~~ trstun
trstprl ~~ trstep
'
fit_politics_adj_2 <- cfa(politics_model_adj_2,
data = df_subset)
summary(fit_politics_adj_2, fit.measures=T, standardized=T)
graph_data <- prepare_graph(fit_politics_adj_2)
edges(graph_data) <- graph_data %>%
edges() %>%
mutate(colour = "black")
plot(graph_data,
#label = "est_std",   # get standardized results (not rounded)
angle = 170          # adjust the arrows
)
# So then add in mediation model.
politics_model_adj_2 <- '
# Specify latent factors
# Trust in government
gov_trust =~ trstprl + trstprt + trstep + trstun
# Trust in people
people_trust =~ ppltrst + pplfair + pplhlp
# Poltical ability
poltical_able =~ psppipla + psppsgva + cptppola
# Add residual covariance
trstep ~~ trstun
trstprl ~~ trstep
## Direct effect(s) ##
gov_trust ~ c1*people_trust + c2*gndr
#### Mediator ##
### Path A
##egual ~ a1*agea + a2*eduyrs + a3*hinctnta + a4*gndr
##
### Path B
##welf_supp ~ b*egual
##
#### Indirect effect (a*b) ##
##ab_age := a1*b
##a1b_edu := a2*b
##a2b_inco := a3*b
##a3b_gndr := a4*b
##
#### Total effect ##
##total_age := c1 + (a1*b)
##total1_edu := c2 + (a2*b)
total2_inco := c3 + (a3*b)
total3_gndr := c4 + (a4*b)
'
fit_mediation <- cfa(politics_mediation,
data = df_subset)
fit_mediation <- cfa(politics_mediation_model,
data = df_subset)
# So then add in mediation model.
politics_mediation_model <- '
# Specify latent factors
# Trust in government
gov_trust =~ trstprl + trstprt + trstep + trstun
# Trust in people
people_trust =~ ppltrst + pplfair + pplhlp
# Poltical ability
poltical_able =~ psppipla + psppsgva + cptppola
# Add residual covariance
trstep ~~ trstun
trstprl ~~ trstep
## Direct effect(s) ##
gov_trust ~ c1*people_trust + c2*gndr
#### Mediator ##
### Path A
##egual ~ a1*agea + a2*eduyrs + a3*hinctnta + a4*gndr
##
### Path B
##welf_supp ~ b*egual
##
#### Indirect effect (a*b) ##
##ab_age := a1*b
##a1b_edu := a2*b
##a2b_inco := a3*b
##a3b_gndr := a4*b
##
#### Total effect ##
##total_age := c1 + (a1*b)
##total1_edu := c2 + (a2*b)
total2_inco := c3 + (a3*b)
total3_gndr := c4 + (a4*b)
'
fit_mediation <- cfa(politics_mediation_model,
data = df_subset)
# So then add in mediation model.
politics_mediation_model <- '
# Specify latent factors
# Trust in government
gov_trust =~ trstprl + trstprt + trstep + trstun
# Trust in people
people_trust =~ ppltrst + pplfair + pplhlp
# Poltical ability
poltical_able =~ psppipla + psppsgva + cptppola
# Add residual covariance
trstep ~~ trstun
trstprl ~~ trstep
## Direct effect(s) ##
gov_trust ~ c1*people_trust + c2*gndr
#### Mediator ##
### Path A
##egual ~ a1*agea + a2*eduyrs + a3*hinctnta + a4*gndr
##
### Path B
##welf_supp ~ b*egual
##
#### Indirect effect (a*b) ##
##ab_age := a1*b
##a1b_edu := a2*b
##a2b_inco := a3*b
##a3b_gndr := a4*b
##
#### Total effect ##
##total_age := c1 + (a1*b)
##total1_edu := c2 + (a2*b)
##total2_inco := c3 + (a3*b)
##total3_gndr := c4 + (a4*b)
'
fit_mediation <- cfa(politics_mediation_model,
data = df_subset)
summary(fit_mediation, fit.measures=T, standardized=T)
# So then add in mediation model.
politics_mediation_model <- '
# Specify latent factors
# Trust in government
gov_trust =~ trstprl + trstprt + trstep + trstun
# Trust in people
people_trust =~ ppltrst + pplfair + pplhlp
# Poltical ability
poltical_able =~ psppipla + psppsgva + cptppola
# Add residual covariance
trstep ~~ trstun
trstprl ~~ trstep
## Direct effect(s) ##
gov_trust ~ c1*people_trust + c2*gndr + c3*polintr
#### Mediator ##
### Path A
##egual ~ a1*agea + a2*eduyrs + a3*hinctnta + a4*gndr
##
### Path B
##welf_supp ~ b*egual
##
#### Indirect effect (a*b) ##
##ab_age := a1*b
##a1b_edu := a2*b
##a2b_inco := a3*b
##a3b_gndr := a4*b
##
#### Total effect ##
##total_age := c1 + (a1*b)
##total1_edu := c2 + (a2*b)
##total2_inco := c3 + (a3*b)
##total3_gndr := c4 + (a4*b)
'
fit_mediation <- cfa(politics_mediation_model,
data = df_subset)
summary(fit_mediation, fit.measures=T, standardized=T)
# So then add in mediation model.
politics_mediation_model <- '
# Specify latent factors
# Trust in government
gov_trust =~ trstprl + trstprt + trstep + trstun
# Trust in people
people_trust =~ ppltrst + pplfair + pplhlp
# Poltical ability
poltical_able =~ psppipla + psppsgva + cptppola
# Add residual covariance
trstep ~~ trstun
trstprl ~~ trstep
## Direct effect(s) ##
poltical_able ~ c1*polintr
## Mediator ##
## Path A
gov_trust ~ a1*people_trust + a2*polintr
## Path B
poltical_able ~ b1*gov_trust
## Indirect effect (a*b) ##
ab_trust := a1*b1
ab_interest := a2*b1
## Total effect ##
total_interest := c1 + ab_interest
'
fit_mediation <- cfa(politics_mediation_model,
data = df_subset)
summary(fit_mediation, fit.measures=T, standardized=T)
graph_data <- prepare_graph(mediation)
edges(graph_data) <- graph_data %>%
edges() %>%
mutate(colour = "black")
plot(graph_data,
#label = "est_std",   # get standardized results (not rounded)
angle = 170          # adjust the arrows
)
# Or fit multigroup model.
df_subset$gndr <- factor(df_subset$gndr,
levels = c("1", "2"),         # levels
labels = c("Male", "Female")) # labels
fit_media <- cfa(fit_politics_adj_2,
data = df_subset , group="gndr")
summary(fit_media,standardized=T)
# Let's remove actrolga
politics_model_adj_2 <- '
# Specify latent factors
# Trust in government
gov_trust =~ trstprl + trstprt + trstep + trstun
# Trust in people
people_trust =~ ppltrst + pplfair + pplhlp
# Poltical ability
poltical_able =~ psppipla + psppsgva + cptppola
# Add residual covariance
trstep ~~ trstun
trstprl ~~ trstep
'
fit_media <- cfa(politics_model_adj_2,
data = df_subset , group="gndr")
summary(fit_media,standardized=T)
# The code will generate univariate forecasts for each chemical  for each measuring station of interest
library(tidyverse)
library(ggplot2)
library(lubridate)
library(readxl)
library(CADFtest)
library(vars)
library(imputeTS)
library(kableExtra)
library(forecast)
# Load selected stations as generated by station_select_for_mvts.R
station_file="d:/asus_documents/ku_leuven/thesis/data/selected_stations_for_training.txt"
selected_stations <- read.table(station_file)
names(selected_stations) <- c("station")
selected_stations
dim(selected_stations)
library(tidyverse)
library(ggplot2)
library(lubridate)
library(readxl)
library(CADFtest)
library(vars)
library(imputeTS)
library(kableExtra)
library(forecast)
user_dir = "D:/asus_documents/ku_leuven/thesis/code/multi-modal-pollution/src/modelling"
setwd(user_dir)
# load covid data.
covid_df <- read_excel("d:/linux_documents_11_2021/thesis/code/multi-modal-pollution/data/covid/covid19be.xlsx")
head(covid_df)
names(covid_df) <- tolower(names(covid_df))
head(covid_df)
# aggregate the classes.
covid_df %>% group_by()
covid_flanders <- covid_df %>% dplyr::filter(region=="Flanders") %>%
mutate(day=lubridate::ceiling_date(date, "day")) %>%
group_by(day) %>% summarise(total_cases=sum(cases))
covid_subset <- covid_flanders %>% dplyr::filter(day > "2020-03-01" & day <= "2021-06-02")
covid_subset
nrow(covid_subset)
min(covid_subset$day)
max(covid_subset$day)
# create covid ts
cov_ts <- ts(covid_subset$total_cases, frequency=7, start=c(2020, 9))
length(cov_ts)
#plot.ts(cov_ts)
png(filename="d:/asus_documents/ku_leuven/thesis/figures/covid_ts/cov_ts.png", width=1000)
p <- ggplot(covid_subset, aes(x=day, y=total_cases)) +
geom_line() +
ggtitle("Daily COVID-19 cases, Flanders") +
xlab("2020") +
ylab("Daily cases")
p
dev.off()
plot.ts(cov_ts)
# test for non stationarity
cov_max_lag=round(sqrt(length(cov_ts)))
CADFtest(cov_ts, type= "drift", criterion= "BIC", max.lag.y=cov_max_lag)
CADFtest(diff(cov_ts), type= "drift", criterion= "BIC", max.lag.y=cov_max_lag)
png(filename="d:/asus_documents/ku_leuven/courses/time_series/project/figures/cov_acf.png")
acf(cov_ts)
dev.off()
# then load the traffic data.
traffic_df <- read_excel(
path="d:/linux_documents_11_2021/thesis/code/multi-modal-pollution/data/traffic/20210921-tunnels2019-sept2021.xlsx"
)
names(traffic_df) <- tolower(names(traffic_df))
head(traffic_df)
nrow(traffic_df)
# first need to select the detector to use.
traffic_summary <- traffic_df %>% dplyr::group_by(detector) %>%
summarise(avg_tf=mean(volume, na.rm=T), sd_tf=sd(volume, na.rm=T), len=n()) %>%
arrange(desc(avg_tf))
traffic_summary
# using tun bel in because it has data for longest period with a high average
detector_df <- traffic_df %>% dplyr::filter(detector=="Tun Bel IN")
# TODO: Pick measurement station or aggregation method
#detector_df <- traffic_df %>% dplyr::filter(detector=="Tun VP - A12")
nrow(detector_df)
detector_df$from <- ymd_hms(detector_df$from)
min(detector_df$from)
max(detector_df$from)
head(detector_df)
# this detector starts at 2019-01-01 00:00:00
# day duration counter https://www.timeanddate.com/date/duration.html?d1=01&m1=01&y1=2019&d2=&m2=&y2=&ti=on&
detector_subset <- detector_df %>% dplyr::filter(from > "2020-03-01 00:00:00" & from <= "2021-06-01")
min(detector_subset$from)
max(detector_subset$from)
nrow(detector_subset)
# fill in missing dates
# https://blog.exploratory.io/populating-missing-dates-with-complete-and-fill-functions-in-r-and-exploratory-79f2a321e6b5
detector_complete <- detector_subset %>% complete(from = seq(min(from), max(from), by="hour"))
nrow(detector_complete)
detector_complete[1:3, "from"]
# next do imputation.
statsNA(as.matrix(detector_complete$volume))
# run imputations
# choice between linear, spline, and stineman interpolations
# need to round for some reason.
detector_complete$volume_inter <- round(na_interpolation(detector_complete$volume),1)
ggplot_na_imputations(detector_complete$volume, detector_complete$volume_inter)
statsNA(as.matrix(detector_complete$volume_inter))
# aggregate by day, but need to round up if staying in 2019
traffic_daily <- detector_complete %>% mutate(day=lubridate::ceiling_date(from, "day")) %>% group_by(day) %>%
summarise(daily_volume=mean(volume_inter))
traffic_daily
nrow(traffic_daily)
min(traffic_daily$day)
max(traffic_daily$day)
# create the ts
traffic_ts <- ts(traffic_daily$daily_volume, frequency=7, start=c(2020, 9))
stopifnot(length(traffic_ts)==458)
png(filename="d:/asus_documents/ku_leuven/thesis/figures/traffic_ts/traffic_ts.png", width=1000)
p <- ggplot(traffic_daily, aes(x=day, y=daily_volume)) +
geom_line() +
ggtitle("Daily traffic volume, Brussels Tunnel") +
xlab("2020") +
ylab("Daily volume")
p
dev.off()
# test for non stationarity
tf_max_lag=round(sqrt(length(traffic_ts)))
CADFtest(traffic_ts, type= "drift", criterion= "BIC", max.lag.y=tf_max_lag)
CADFtest(diff(traffic_ts), type= "drift", criterion= "BIC", max.lag.y=tf_max_lag)
acf(traffic_ts)
pacf(traffic_ts)
d_traffic <- diff(traffic_ts)
acf(d_traffic)
pacf(d_traffic)
acf(diff(d_traffic, 7))
pacf(diff(d_traffic))
# Testing for cointegration
length(cov_ts)
length(air_ts)
length(diff(traffic_ts))
# Set up dfs
var_df_cov <- data.frame(air_ts, traffic_ts, cov_ts)
var_df_no_cov <- data.frame(air_ts, traffic_ts)
var_df_no_air <- data.frame(traffic_ts, cov_ts)
# lag of 9
names(var_df_cov)<-c("air","traffic", "covid")
names(var_df_no_cov)<-c("air","traffic")
names(var_df_no_air)<-c("traffic","covid")
VARselect(var_df_cov,lag.max=10,type="const")
# order 8
VARselect(var_df_no_cov,lag.max=10,type="const")
# by sic we select order 8
VARselect(var_df_no_air,lag.max=10,type="const")
# Testing cointegration
# This first test is the most important, because we have to check if the two
# non-stationary series are cointegrated.
trace1 <- ca.jo(var_df_no_air,type="trace",K=9,ecdet="const",spec="transitory")
summary(trace1)
# The result supposts cointegration with 1 test equation.
trace2 <- ca.jo(var_df_cov,type="trace",K=8,ecdet="const",spec="transitory")
summary(trace2)
# When including that stationary air series, we get 2 test equations, though the second
# is rather on the boundary b/w signficant and not
# This test below is not necessary:
trace3 <- ca.jo(var_df_no_cov,type="trace",K=8,ecdet="const",spec="transitory")
summary(trace3)
#repeat the same procedure using johansen’s maximum eigenvalue test statistic.
# const is constant term in the long run relationshp
# transitory means to not include a deterministic trend in the test equation.
# we interpret this test as we did for the prvious test
maxeigen_test <- ca.jo(var_df_no_air,type="eigen",K=9,ecdet="const",spec="transitory")
summary(maxeigen_test)
# Load selected stations as generated by station_select_for_mvts.R
station_file="d:/asus_documents/ku_leuven/thesis/data/selected_stations_for_training.txt"
